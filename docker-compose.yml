# Docker Compose for Rune MCP Server Development

services:
  rune:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        NODE_VERSION: 22
        ALPINE_VERSION: 3.22
        RUST_VERSION: 1.89
        BUILD_DATE: ${BUILD_DATE:-}
        GIT_COMMIT: ${GIT_COMMIT:-}
        VERSION: ${VERSION:-latest}
    container_name: rune
    volumes:
      # Mount workspace as read-only for security
      - ${RUNE_WORKSPACE:-${HOME}/Projects}:/workspace:ro
      # Persistent data storage
      - ${RUNE_DATA:-~/.rune}:/data
    ports:
      # MCP port - only expose for debugging
      - "${MCP_PORT:-3333}:3333"
    environment:
      # Core configuration
      - NODE_ENV=production
      - RUNE_WORKSPACE=/workspace
      - RUNE_CACHE_DIR=/data/cache
      # Performance tuning
      - RUNE_INDEXING_THREADS=${RUNE_INDEXING_THREADS:-4}
      - RUNE_MAX_FILE_SIZE=${RUNE_MAX_FILE_SIZE:-10485760}
      # Semantic search
      - RUNE_ENABLE_SEMANTIC=${RUNE_ENABLE_SEMANTIC:-true}
      - QDRANT_URL=http://localhost:6334
      - QDRANT_STORAGE=/data/qdrant
      # Languages to support
      - RUNE_LANGUAGES=${RUNE_LANGUAGES:-rust,javascript,typescript,python,go,java,cpp}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3333/health"]
      interval: 30s
      timeout: 10s
      start_period: 60s
      retries: 3
    # Resource limits (optional, uncomment to enable)
    # deploy:
    #   resources:
    #     limits:
    #       cpus: '2'
    #       memory: 2G
    #     reservations:
    #       cpus: '1'
    #       memory: 512M
    networks:
      - rune-network

networks:
  rune-network:
    driver: bridge
